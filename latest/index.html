<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RobotOS.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RobotOS.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Usage:-Type-Generation-1">Usage: Type Generation</a></li><li><a class="toctext" href="#Usage:-ROS-API-1">Usage: ROS API</a></li><li><a class="toctext" href="#ROS-Integration-1">ROS Integration</a></li><li><a class="toctext" href="#Full-example-1">Full example</a></li><li><a class="toctext" href="#Versions-1">Versions</a></li></ul></li><li><a class="toctext" href="api.html">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/jdlangs/RobotOS.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="RobotOS.jl-Documentation-1" href="#RobotOS.jl-Documentation-1">RobotOS.jl Documentation</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><h3><a class="nav-anchor" id="Description-1" href="#Description-1">Description</a></h3><p>This package enables interfacing Julia code with a ROS (<a href="http://wiki.ros.org">Robot Operating System</a>) system. It works by generating native Julia types for ROS types, the same as in C++ or Python, and then wrapping rospy through the PyCall package to get communication through topics, services, and parameters.</p><h3><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h3><pre><code class="language-none">Pkg.add(&quot;RobotOS&quot;)
using RobotOS</code></pre><h3><a class="nav-anchor" id="Contributing-1" href="#Contributing-1">Contributing</a></h3><p>The package will hopefully continue to undergo substantial improvement. Please feel free to submit either an issue or pull request through github if you want to fix something or suggest a needed improvment, even if it&#39;s just to add an extra sentence in this README.</p><h4><a class="nav-anchor" id="Testing-1" href="#Testing-1">Testing</a></h4><p>Currently, <code>Pkg.test(&quot;RobotOS&quot;)</code> requires some bootstrapping to work properly. Before running Julia, make sure a ROS master is running and start the helper node by running the <code>test/echonode.py</code> file.</p><h2><a class="nav-anchor" id="Usage:-Type-Generation-1" href="#Usage:-Type-Generation-1">Usage: Type Generation</a></h2><p>ROS types are brought into your program with the <code>@rosimport</code> macro which specifies a package and one or more types. The three valid syntax forms can be seen in these examples:</p><pre><code class="language-none">@rosimport std_msgs.msg.Header
@rosimport nav_msgs.srv: GetPlan
@rosimport geometry_msgs.msg: PoseStamped, Vector3</code></pre><p><code>@rosimport</code> will import the python modules for the requested type and all its dependencies but the native Julia types are not created yet since any inter-module dependencies have to be resolved first. After the final <code>@rosimport</code> call, initiate the type generation with:</p><pre><code class="language-none">rostypegen()</code></pre><p>The new types will be placed in newly created modules in <code>Main</code>, corresponding to the packages requested. For example, <code>&quot;std_msgs/Header&quot; =&gt; std_msgs.msg.Header</code>. After calling <code>rostypegen()</code> they can be interacted with just like regular modules with <code>import</code> and <code>using</code> statements bringing the generated type names into the local namespace.</p><pre><code class="language-none">using nav_msgs.msg
import geometry_msgs.msg: Pose, Vector3
p = Path()
v = Vector3(1.1,2.2,3.3)</code></pre><p>There is one special case, where the ROS type name conflicts with a built-in Julia type name (e.g., <code>std_msgs/Float64</code> or <code>std_msgs/String</code>). In these cases, the generated Julia type will have &quot;Msg&quot; appended to the name for disambiguation (e.g., <code>std_msgs.msg.Float64Msg</code> and <code>std_msgs.msg.StringMsg</code>).</p><p>An additional function, <code>rostypereset()</code>, resets the type generation process, possibly useful for development in the REPL. When invoked, new <code>@rosimport</code> calls will be needed to generate the same or different types, and previously generated modules will be overwritten after <code>rostypegen()</code> is called again.  Keep in mind that names cannot be cleared once defined so if a module is not regenerated, the first version will remain.</p><h2><a class="nav-anchor" id="Usage:-ROS-API-1" href="#Usage:-ROS-API-1">Usage: ROS API</a></h2><p>In general, the API functions provided directly match those provided in rospy, with few cosmetic differences. The rospy API functions can reviewed here: <a href="http://wiki.ros.org/rospy/Overview">http://wiki.ros.org/rospy/Overview</a></p><h3><a class="nav-anchor" id="General-Functions-1" href="#General-Functions-1">General Functions</a></h3><ul><li><p><code>init_node(name::String; kwargs...)</code> : Initialize node. Passes keyword</p></li></ul><p>arguments on to rospy directly. (Required)</p><ul><li><p><code>is_shutdown()</code> : Check for ROS shutdown state.</p></li><li><p><code>spin()</code> :  Wait for callbacks until shutdown happens.</p></li><li><p><code>logdebug</code>,<code>loginfo</code>,<code>logwarn</code>,<code>logerr</code>,<code>logfatal</code> all work as in rospy.</p></li></ul><h3><a class="nav-anchor" id="Time-1" href="#Time-1">Time</a></h3><p>Native Julia types <code>Time</code> and <code>Duration</code> are defined, both as a composite of an integral number of seconds and nanoseconds, as in rospy.  Arithmetic and comparison operators are also defined. A <code>Rate</code> type is defined as a wrapper for the rospy Rate, which keeps loops running on a near fixed time interval. It can be constructed with a <code>Duration</code> object, or a floating-point value, specifying the loop rate in Hz. Other functions are:</p><ul><li><p><code>get_rostime()</code>, <code>RobotOS.now()</code> : Current time as <code>Time</code> object.</p></li><li><p><code>to_sec(time_obj)</code>, <code>convert(Float64, time_obj)</code> : Convert <code>Time</code> or</p></li></ul><p><code>Duration</code> object to floating-point number of seconds.</p><ul><li><p><code>to_nsec(time_obj)</code> : Convert object to integral number of nanoseconds.</p></li><li><p><code>rossleep(t)</code> with <code>t</code> of type <code>Duration</code>, <code>Rate</code>, <code>Real</code>. Also</p></li></ul><p><code>sleep(t::Duration)</code> and <code>sleep(t::Rate)</code> : Sleep the amount implied by type and value of the <code>t</code> parameter.</p><h3><a class="nav-anchor" id="Publishing-Messages-1" href="#Publishing-Messages-1">Publishing Messages</a></h3><p>Publishing messages is the same as in rospy, except use the <code>publish</code> method, paired with a Publisher object. For example:</p><pre><code class="language-none">using geometry_msgs.msg
pub = Publisher{PointStamped}(&quot;topic&quot;, queue_size = 10) #or...
#pub = Publisher(&quot;topic&quot;, PointStamped, queue_size = 10)
msg = PointStamped()
msg.header.stamp = now()
msg.point.x = 1.1
publish(pub, msg)</code></pre><p>The keyword arguments in the <code>Publisher</code> constructor are passed directly on to rospy so anything it accepts will be valid.</p><h3><a class="nav-anchor" id="Subscribing-to-a-Topic-1" href="#Subscribing-to-a-Topic-1">Subscribing to a Topic</a></h3><p>Subscribing to a topic is the same as in rospy. When creating a <code>Subscriber</code>, an optional <code>callback_args</code> parameter can be given to forward on whenever the callback is invoked. Note that it must be passed as a tuple, even if there is only a single argument. And again, keyword arguments are directly forwarded. An example:</p><pre><code class="language-none">using sensor_msgs.msg
cb1(msg::Imu, a::String) = println(a,&quot;: &quot;,msg.linear_acceleration.x)
cb2(msg::Imu) = println(msg.angular_velocity.z)
sub1 = Subscriber{Imu}(&quot;topic&quot;, cb1, (&quot;accel&quot;,), queue_size = 10) #or...
#sub1 = Subscriber(&quot;topic&quot;, Imu, cb1, (&quot;accel&quot;,), queue_size = 10)
sub2 = Subscriber{Imu}(&quot;topic&quot;, cb2, queue_size = 10)
spin()</code></pre><h3><a class="nav-anchor" id="Using-services-1" href="#Using-services-1">Using services</a></h3><p>ROS services are fully supported, including automatic request and response type generation. For the <code>@rosimport</code> call, use the plain service type name. After <code>rostypegen()</code>, the generated <code>.srv</code> submodule will contain 3 types: the plain type, a request type, and a response type. For example <code>@rosimport nav_msgs.srv.GetPlan</code> will create <code>GetPlan</code>, <code>GetPlanRequest</code>, and <code>GetPlanResponse</code>. To provide the service to other nodes, you would create a <code>Service{GetPlan}</code> object. To call it, a <code>ServiceProxy{GetPlan}</code> object. The syntax exactly matches rospy to construct and use these objects. For example, if <code>myproxy</code> is a <code>ServiceProxy</code> object, it can be called with <code>myproxy(my_request)</code>.</p><h3><a class="nav-anchor" id="Parameter-Server-1" href="#Parameter-Server-1">Parameter Server</a></h3><p><code>get_param</code>, <code>set_param</code>, <code>has_param</code>, and <code>delete_param</code> are all implemented in the <code>RobotOS</code> module with the same syntax as in rospy.</p><h3><a class="nav-anchor" id="Message-Constants-1" href="#Message-Constants-1">Message Constants</a></h3><p>Message constants may be accessed using <code>getindex</code> syntax. For example for <a href="http://docs.ros.org/api/visualization_msgs/html/msg/Marker.html">visualization_msgs/Marker.msg</a> we have:</p><pre><code class="language-none">import visualization_msgs.msg: Marker
Marker[:SPHERE] == getindex(Marker, :SPHERE) == 2   # true</code></pre><h2><a class="nav-anchor" id="ROS-Integration-1" href="#ROS-Integration-1">ROS Integration</a></h2><p>Since Julia code needs no prior compilation, it is possible to integrate very tightly and natively with a larger ROS system. Just make sure you:</p><ul><li><p>Keep your code inside your ROS packages as usual.</p></li><li><p>Ensure your .jl script is executable (e.g., <code>chmod a+x script.jl</code>) and has</p></li></ul><p>the hint to the Julia binary as the first line (<code>#!/usr/bin/env julia</code>).</p><p>Now your Julia code will run exactly like any python script that gets invoked through <code>rosrun</code> or <code>roslaunch</code>. And since <code>include</code> takes paths relative to the location of the calling file, you can bring in whatever other modules or functions reside in your package from the single executable script.</p><pre><code class="language-none">#!/usr/bin/env julia
#main.jl in thebot_pkg/src
using RobotOS

include(&quot;BotSrc/Bot.jl&quot;)
using Bot
#...</code></pre><h2><a class="nav-anchor" id="Full-example-1" href="#Full-example-1">Full example</a></h2><p>This example demonstrates publishing a random <code>geometry_msgs/Point</code> message at 5 Hz. It also listens for incoming <code>geometry_msgs/Pose2D</code> messages and republishes them as Points.</p><pre><code class="language-none">#!/usr/bin/env julia

using RobotOS
@rosimport geometry_msgs.msg: Point, Pose2D
rostypegen()
using geometry_msgs.msg

function callback(msg::Pose2D, pub_obj::Publisher{Point})
    pt_msg = Point(msg.x, msg.y, 0.0)
    publish(pub_obj, pt_msg)
end

function loop(pub_obj)
    loop_rate = Rate(5.0)
    while ! is_shutdown()
        npt = Point(rand(), rand(), 0.0)
        publish(pub_obj, npt)
        rossleep(loop_rate)
    end
end

function main()
    init_node(&quot;rosjl_example&quot;)
    pub = Publisher{Point}(&quot;pts&quot;, queue_size=10)
    sub = Subscriber{Pose2D}(&quot;pose&quot;, callback, (pub,), queue_size=10)
    loop(pub)
end

if ! isinteractive()
    main()
end</code></pre><h2><a class="nav-anchor" id="Versions-1" href="#Versions-1">Versions</a></h2><ul><li><p><code>0.1</code> : Initial release</p></li><li><p><code>0.2</code> : Changed type gen API and moved generated modules to Main</p></li><li><p><code>0.3</code> : Added service type generation and API</p></li><li><p><code>0.4</code> : Julia v0.4+ support only</p></li></ul><footer><hr/><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API Reference</span></a></footer></article></body></html>
