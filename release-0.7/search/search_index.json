{
    "docs": [
        {
            "location": "/", 
            "text": "RobotOS.jl Documentation\n\n\n\n\nOverview\n\n\n\n\nDescription\n\n\nThis package enables interfacing Julia code with a ROS (\nRobot Operating System\n) system. It works by generating native Julia types for ROS types, the same as in C++ or Python, and then wrapping rospy through the PyCall package to get communication through topics, services, and parameters.\n\n\n\n\nInstallation\n\n\nPkg\n.\nadd\n(\nRobotOS\n)\n\n\nusing\n \nRobotOS\n\n\n\n\n\n\n\n\nContributing\n\n\nThe package will hopefully continue to undergo substantial improvement. Please feel free to submit either an issue or pull request through github if you want to fix something or suggest a needed improvment, even if it's just to add an extra sentence in this README.\n\n\n\n\nTesting\n\n\nCurrently, \nPkg.test(\"RobotOS\")\n requires some bootstrapping to work properly. Before running Julia, make sure a ROS master is running and start the helper node by running the \ntest/echonode.py\n file.\n\n\n\n\nUsage: Type Generation\n\n\nROS types are brought into your program with the \n@rosimport\n macro which specifies a package and one or more types. The three valid syntax forms can be seen in these examples:\n\n\n@\nrosimport\n \nstd_msgs\n.\nmsg\n.\nHeader\n\n\n@\nrosimport\n \nnav_msgs\n.\nsrv\n:\n \nGetPlan\n\n\n@\nrosimport\n \ngeometry_msgs\n.\nmsg\n:\n \nPoseStamped\n,\n \nVector3\n\n\n\n\n\n\n@rosimport\n will import the python modules for the requested type and all its dependencies but the native Julia types are not created yet since any inter-module dependencies have to be resolved first. After the final \n@rosimport\n call, initiate the type generation with:\n\n\nrostypegen\n()\n\n\n\n\n\n\nThe new types will be placed in newly created modules in \nMain\n, corresponding to the packages requested. For example, \n\"std_msgs/Header\" =\n std_msgs.msg.Header\n. After calling \nrostypegen()\n they can be interacted with just like regular modules with \nimport\n and \nusing\n statements bringing the generated type names into the local namespace.\n\n\nusing\n \nnav_msgs\n.\nmsg\n\n\nimport\n \ngeometry_msgs\n.\nmsg\n:\n \nPose\n,\n \nVector3\n\n\np\n \n=\n \nPath\n()\n\n\nv\n \n=\n \nVector3\n(\n1.1\n,\n2.2\n,\n3.3\n)\n\n\n\n\n\n\nThere is one special case, where the ROS type name conflicts with a built-in Julia type name (e.g., \nstd_msgs/Float64\n or \nstd_msgs/String\n). In these cases, the generated Julia type will have \"Msg\" appended to the name for disambiguation (e.g., \nstd_msgs.msg.Float64Msg\n and \nstd_msgs.msg.StringMsg\n).\n\n\nAn additional function, \nrostypereset()\n, resets the type generation process, possibly useful for development in the REPL. When invoked, new \n@rosimport\n calls will be needed to generate the same or different types, and previously generated modules will be overwritten after \nrostypegen()\n is called again.  Keep in mind that names cannot be cleared once defined so if a module is not regenerated, the first version will remain.\n\n\n\n\nCompatibility with Package Precompilation\n\n\nAs described above, by default \nrostypegen\n creates modules in \nMain\n \u2013 however, this behavior is incompatible with Julia package precompilation. If you are using \nRobotOS\n in your own module or package, as opposed to a script, you may reduce load-time latency (useful for real-life applications!) by generating the ROS type modules inside your package module using an approach similar to the example below:\n\n\n# MyROSPackage.jl\n\n\nmodule\n \nMyROSPackage\n\n\n\nusing\n \nRobotOS\n\n\n\n@\nrosimport\n \ngeometry_msgs\n.\nmsg\n:\n \nPose\n\n\nrostypegen\n(\n@\n__MODULE__\n)\n\n\nimport\n \n.\ngeometry_msgs\n.\nmsg\n:\n \nPose\n\n\n# ...\n\n\n\nend\n\n\n\n\n\n\nIn this case, we have provided \nrostypegen\n with a root module (\nMyROSPackage\n) for type generation. The Julia type corresponding to \ngeometry_msgs/Pose\n now lives at \nMyROSPackage.geometry_msgs.msg.Pose\n; note the extra dot in \nimport .geometry_msgs.msg: Pose\n.\n\n\n\n\nUsage: ROS API\n\n\nIn general, the API functions provided directly match those provided in rospy, with few cosmetic differences. The rospy API functions can reviewed here: \nhttp://wiki.ros.org/rospy/Overview\n\n\n\n\nGeneral Functions\n\n\n\n\ninit_node(name::String; kwargs...)\n : Initialize node. Passes keyword\n\n\n\n\narguments on to rospy directly. (Required)\n\n\n\n\nis_shutdown()\n : Check for ROS shutdown state.\n\n\nspin()\n :  Wait for callbacks until shutdown happens.\n\n\nlogdebug\n,\nloginfo\n,\nlogwarn\n,\nlogerr\n,\nlogfatal\n all work as in rospy.\n\n\n\n\n\n\nTime\n\n\nNative Julia types \nTime\n and \nDuration\n are defined, both as a composite of an integral number of seconds and nanoseconds, as in rospy.  Arithmetic and comparison operators are also defined. A \nRate\n type is defined as a wrapper for the rospy Rate, which keeps loops running on a near fixed time interval. It can be constructed with a \nDuration\n object, or a floating-point value, specifying the loop rate in Hz. Other functions are:\n\n\n\n\nget_rostime()\n, \nRobotOS.now()\n : Current time as \nTime\n object.\n\n\nto_sec(time_obj)\n, \nconvert(Float64, time_obj)\n : Convert \nTime\n or\n\n\n\n\nDuration\n object to floating-point number of seconds.\n\n\n\n\nto_nsec(time_obj)\n : Convert object to integral number of nanoseconds.\n\n\nrossleep(t)\n with \nt\n of type \nDuration\n, \nRate\n, \nReal\n. Also\n\n\n\n\nsleep(t::Duration)\n and \nsleep(t::Rate)\n : Sleep the amount implied by type and value of the \nt\n parameter.\n\n\n\n\nPublishing Messages\n\n\nPublishing messages is the same as in rospy, except use the \npublish\n method, paired with a Publisher object. For example:\n\n\nusing\n \ngeometry_msgs\n.\nmsg\n\n\npub\n \n=\n \nPublisher\n{\nPointStamped\n}(\ntopic\n,\n \nqueue_size\n \n=\n \n10\n)\n \n#\nor\n...\n\n\n#pub = Publisher(\ntopic\n, PointStamped, queue_size = 10)\n\n\nmsg\n \n=\n \nPointStamped\n()\n\n\nmsg\n.\nheader\n.\nstamp\n \n=\n \nnow\n()\n\n\nmsg\n.\npoint\n.\nx\n \n=\n \n1.1\n\n\npublish\n(\npub\n,\n \nmsg\n)\n\n\n\n\n\n\nThe keyword arguments in the \nPublisher\n constructor are passed directly on to rospy so anything it accepts will be valid.\n\n\n\n\nSubscribing to a Topic\n\n\nSubscribing to a topic is the same as in rospy. When creating a \nSubscriber\n, an optional \ncallback_args\n parameter can be given to forward on whenever the callback is invoked. Note that it must be passed as a tuple, even if there is only a single argument. And again, keyword arguments are directly forwarded. An example:\n\n\nusing\n \nsensor_msgs\n.\nmsg\n\n\ncb1\n(\nmsg\n::\nImu\n,\n \na\n::\nString\n)\n \n=\n \nprintln\n(\na\n,\n: \n,\nmsg\n.\nlinear_acceleration\n.\nx\n)\n\n\ncb2\n(\nmsg\n::\nImu\n)\n \n=\n \nprintln\n(\nmsg\n.\nangular_velocity\n.\nz\n)\n\n\nsub1\n \n=\n \nSubscriber\n{\nImu\n}(\ntopic\n,\n \ncb1\n,\n \n(\naccel\n,),\n \nqueue_size\n \n=\n \n10\n)\n \n#\nor\n...\n\n\n#sub1 = Subscriber(\ntopic\n, Imu, cb1, (\naccel\n,), queue_size = 10)\n\n\nsub2\n \n=\n \nSubscriber\n{\nImu\n}(\ntopic\n,\n \ncb2\n,\n \nqueue_size\n \n=\n \n10\n)\n\n\nspin\n()\n\n\n\n\n\n\n\n\nUsing services\n\n\nROS services are fully supported, including automatic request and response type generation. For the \n@rosimport\n call, use the plain service type name. After \nrostypegen()\n, the generated \n.srv\n submodule will contain 3 types: the plain type, a request type, and a response type. For example \n@rosimport nav_msgs.srv.GetPlan\n will create \nGetPlan\n, \nGetPlanRequest\n, and \nGetPlanResponse\n. To provide the service to other nodes, you would create a \nService{GetPlan}\n object. To call it, a \nServiceProxy{GetPlan}\n object. The syntax exactly matches rospy to construct and use these objects. For example, if \nmyproxy\n is a \nServiceProxy\n object, it can be called with \nmyproxy(my_request)\n.\n\n\n\n\nParameter Server\n\n\nget_param\n, \nset_param\n, \nhas_param\n, and \ndelete_param\n are all implemented in the \nRobotOS\n module with the same syntax as in rospy.\n\n\n\n\nMessage Constants\n\n\nMessage constants may be accessed using \ngetindex\n syntax. For example for \nvisualization_msgs/Marker.msg\n we have:\n\n\nimport\n \nvisualization_msgs\n.\nmsg\n:\n \nMarker\n\n\nMarker\n[\n:\nSPHERE\n]\n \n==\n \ngetindex\n(\nMarker\n,\n \n:\nSPHERE\n)\n \n==\n \n2\n   \n#\n \ntrue\n\n\n\n\n\n\n\n\nROS Integration\n\n\nSince Julia code needs no prior compilation, it is possible to integrate very tightly and natively with a larger ROS system. Just make sure you:\n\n\n\n\nKeep your code inside your ROS packages as usual.\n\n\nEnsure your .jl script is executable (e.g., \nchmod a+x script.jl\n) and has\n\n\n\n\nthe hint to the Julia binary as the first line (\n#!/usr/bin/env julia\n).\n\n\nNow your Julia code will run exactly like any python script that gets invoked through \nrosrun\n or \nroslaunch\n. And since \ninclude\n takes paths relative to the location of the calling file, you can bring in whatever other modules or functions reside in your package from the single executable script.\n\n\n1\n2\n3\n4\n5\n6\n7\n#!/usr/bin/env julia\n\n\n#main.jl in thebot_pkg/src\n\n\nusing\n \nRobotOS\n\n\n\ninclude\n(\nBotSrc/Bot.jl\n)\n\n\nusing\n \nBot\n\n\n#...\n\n\n\n\n\n\n\n\n\nFull example\n\n\nThis example demonstrates publishing a random \ngeometry_msgs/Point\n message at 5 Hz. It also listens for incoming \ngeometry_msgs/Pose2D\n messages and republishes them as Points.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n#!/usr/bin/env julia\n\n\n\nusing\n \nRobotOS\n\n\n@\nrosimport\n \ngeometry_msgs\n.\nmsg\n:\n \nPoint\n,\n \nPose2D\n\n\nrostypegen\n()\n\n\nusing\n \ngeometry_msgs\n.\nmsg\n\n\n\nfunction\n callback\n(\nmsg\n::\nPose2D\n,\n \npub_obj\n::\nPublisher\n{\nPoint\n})\n\n    \npt_msg\n \n=\n \nPoint\n(\nmsg\n.\nx\n,\n \nmsg\n.\ny\n,\n \n0.0\n)\n\n    \npublish\n(\npub_obj\n,\n \npt_msg\n)\n\n\nend\n\n\n\nfunction\n loop\n(\npub_obj\n)\n\n    \nloop_rate\n \n=\n \nRate\n(\n5.0\n)\n\n    \nwhile\n \n!\n \nis_shutdown\n()\n\n        \nnpt\n \n=\n \nPoint\n(\nrand\n(),\n \nrand\n(),\n \n0.0\n)\n\n        \npublish\n(\npub_obj\n,\n \nnpt\n)\n\n        \nrossleep\n(\nloop_rate\n)\n\n    \nend\n\n\nend\n\n\n\nfunction\n main\n()\n\n    \ninit_node\n(\nrosjl_example\n)\n\n    \npub\n \n=\n \nPublisher\n{\nPoint\n}(\npts\n,\n \nqueue_size\n=\n10\n)\n\n    \nsub\n \n=\n \nSubscriber\n{\nPose2D\n}(\npose\n,\n \ncallback\n,\n \n(\npub\n,),\n \nqueue_size\n=\n10\n)\n\n    \nloop\n(\npub\n)\n\n\nend\n\n\n\nif\n \n!\n \nisinteractive\n()\n\n    \nmain\n()\n\n\nend\n\n\n\n\n\n\n\n\n\nVersions\n\n\n\n\n0.1\n : Initial release\n\n\n0.2\n : Changed type gen API and moved generated modules to Main\n\n\n0.3\n : Added service type generation and API\n\n\n0.4\n : Julia v0.4+ support only\n\n\n0.5\n : Docs website, Julia v0.5+ support only\n\n\n0.6\n : Julia v0.6+ support only", 
            "title": "Introduction"
        }, 
        {
            "location": "/#robotosjl-documentation", 
            "text": "", 
            "title": "RobotOS.jl Documentation"
        }, 
        {
            "location": "/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/#description", 
            "text": "This package enables interfacing Julia code with a ROS ( Robot Operating System ) system. It works by generating native Julia types for ROS types, the same as in C++ or Python, and then wrapping rospy through the PyCall package to get communication through topics, services, and parameters.", 
            "title": "Description"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg . add ( RobotOS )  using   RobotOS", 
            "title": "Installation"
        }, 
        {
            "location": "/#contributing", 
            "text": "The package will hopefully continue to undergo substantial improvement. Please feel free to submit either an issue or pull request through github if you want to fix something or suggest a needed improvment, even if it's just to add an extra sentence in this README.", 
            "title": "Contributing"
        }, 
        {
            "location": "/#testing", 
            "text": "Currently,  Pkg.test(\"RobotOS\")  requires some bootstrapping to work properly. Before running Julia, make sure a ROS master is running and start the helper node by running the  test/echonode.py  file.", 
            "title": "Testing"
        }, 
        {
            "location": "/#usage-type-generation", 
            "text": "ROS types are brought into your program with the  @rosimport  macro which specifies a package and one or more types. The three valid syntax forms can be seen in these examples:  @ rosimport   std_msgs . msg . Header  @ rosimport   nav_msgs . srv :   GetPlan  @ rosimport   geometry_msgs . msg :   PoseStamped ,   Vector3   @rosimport  will import the python modules for the requested type and all its dependencies but the native Julia types are not created yet since any inter-module dependencies have to be resolved first. After the final  @rosimport  call, initiate the type generation with:  rostypegen ()   The new types will be placed in newly created modules in  Main , corresponding to the packages requested. For example,  \"std_msgs/Header\" =  std_msgs.msg.Header . After calling  rostypegen()  they can be interacted with just like regular modules with  import  and  using  statements bringing the generated type names into the local namespace.  using   nav_msgs . msg  import   geometry_msgs . msg :   Pose ,   Vector3  p   =   Path ()  v   =   Vector3 ( 1.1 , 2.2 , 3.3 )   There is one special case, where the ROS type name conflicts with a built-in Julia type name (e.g.,  std_msgs/Float64  or  std_msgs/String ). In these cases, the generated Julia type will have \"Msg\" appended to the name for disambiguation (e.g.,  std_msgs.msg.Float64Msg  and  std_msgs.msg.StringMsg ).  An additional function,  rostypereset() , resets the type generation process, possibly useful for development in the REPL. When invoked, new  @rosimport  calls will be needed to generate the same or different types, and previously generated modules will be overwritten after  rostypegen()  is called again.  Keep in mind that names cannot be cleared once defined so if a module is not regenerated, the first version will remain.", 
            "title": "Usage: Type Generation"
        }, 
        {
            "location": "/#compatibility-with-package-precompilation", 
            "text": "As described above, by default  rostypegen  creates modules in  Main  \u2013 however, this behavior is incompatible with Julia package precompilation. If you are using  RobotOS  in your own module or package, as opposed to a script, you may reduce load-time latency (useful for real-life applications!) by generating the ROS type modules inside your package module using an approach similar to the example below:  # MyROSPackage.jl  module   MyROSPackage  using   RobotOS  @ rosimport   geometry_msgs . msg :   Pose  rostypegen ( @ __MODULE__ )  import   . geometry_msgs . msg :   Pose  # ...  end   In this case, we have provided  rostypegen  with a root module ( MyROSPackage ) for type generation. The Julia type corresponding to  geometry_msgs/Pose  now lives at  MyROSPackage.geometry_msgs.msg.Pose ; note the extra dot in  import .geometry_msgs.msg: Pose .", 
            "title": "Compatibility with Package Precompilation"
        }, 
        {
            "location": "/#usage-ros-api", 
            "text": "In general, the API functions provided directly match those provided in rospy, with few cosmetic differences. The rospy API functions can reviewed here:  http://wiki.ros.org/rospy/Overview", 
            "title": "Usage: ROS API"
        }, 
        {
            "location": "/#general-functions", 
            "text": "init_node(name::String; kwargs...)  : Initialize node. Passes keyword   arguments on to rospy directly. (Required)   is_shutdown()  : Check for ROS shutdown state.  spin()  :  Wait for callbacks until shutdown happens.  logdebug , loginfo , logwarn , logerr , logfatal  all work as in rospy.", 
            "title": "General Functions"
        }, 
        {
            "location": "/#time", 
            "text": "Native Julia types  Time  and  Duration  are defined, both as a composite of an integral number of seconds and nanoseconds, as in rospy.  Arithmetic and comparison operators are also defined. A  Rate  type is defined as a wrapper for the rospy Rate, which keeps loops running on a near fixed time interval. It can be constructed with a  Duration  object, or a floating-point value, specifying the loop rate in Hz. Other functions are:   get_rostime() ,  RobotOS.now()  : Current time as  Time  object.  to_sec(time_obj) ,  convert(Float64, time_obj)  : Convert  Time  or   Duration  object to floating-point number of seconds.   to_nsec(time_obj)  : Convert object to integral number of nanoseconds.  rossleep(t)  with  t  of type  Duration ,  Rate ,  Real . Also   sleep(t::Duration)  and  sleep(t::Rate)  : Sleep the amount implied by type and value of the  t  parameter.", 
            "title": "Time"
        }, 
        {
            "location": "/#publishing-messages", 
            "text": "Publishing messages is the same as in rospy, except use the  publish  method, paired with a Publisher object. For example:  using   geometry_msgs . msg  pub   =   Publisher { PointStamped }( topic ,   queue_size   =   10 )   # or ...  #pub = Publisher( topic , PointStamped, queue_size = 10)  msg   =   PointStamped ()  msg . header . stamp   =   now ()  msg . point . x   =   1.1  publish ( pub ,   msg )   The keyword arguments in the  Publisher  constructor are passed directly on to rospy so anything it accepts will be valid.", 
            "title": "Publishing Messages"
        }, 
        {
            "location": "/#subscribing-to-a-topic", 
            "text": "Subscribing to a topic is the same as in rospy. When creating a  Subscriber , an optional  callback_args  parameter can be given to forward on whenever the callback is invoked. Note that it must be passed as a tuple, even if there is only a single argument. And again, keyword arguments are directly forwarded. An example:  using   sensor_msgs . msg  cb1 ( msg :: Imu ,   a :: String )   =   println ( a , :  , msg . linear_acceleration . x )  cb2 ( msg :: Imu )   =   println ( msg . angular_velocity . z )  sub1   =   Subscriber { Imu }( topic ,   cb1 ,   ( accel ,),   queue_size   =   10 )   # or ...  #sub1 = Subscriber( topic , Imu, cb1, ( accel ,), queue_size = 10)  sub2   =   Subscriber { Imu }( topic ,   cb2 ,   queue_size   =   10 )  spin ()", 
            "title": "Subscribing to a Topic"
        }, 
        {
            "location": "/#using-services", 
            "text": "ROS services are fully supported, including automatic request and response type generation. For the  @rosimport  call, use the plain service type name. After  rostypegen() , the generated  .srv  submodule will contain 3 types: the plain type, a request type, and a response type. For example  @rosimport nav_msgs.srv.GetPlan  will create  GetPlan ,  GetPlanRequest , and  GetPlanResponse . To provide the service to other nodes, you would create a  Service{GetPlan}  object. To call it, a  ServiceProxy{GetPlan}  object. The syntax exactly matches rospy to construct and use these objects. For example, if  myproxy  is a  ServiceProxy  object, it can be called with  myproxy(my_request) .", 
            "title": "Using services"
        }, 
        {
            "location": "/#parameter-server", 
            "text": "get_param ,  set_param ,  has_param , and  delete_param  are all implemented in the  RobotOS  module with the same syntax as in rospy.", 
            "title": "Parameter Server"
        }, 
        {
            "location": "/#message-constants", 
            "text": "Message constants may be accessed using  getindex  syntax. For example for  visualization_msgs/Marker.msg  we have:  import   visualization_msgs . msg :   Marker  Marker [ : SPHERE ]   ==   getindex ( Marker ,   : SPHERE )   ==   2     #   true", 
            "title": "Message Constants"
        }, 
        {
            "location": "/#ros-integration", 
            "text": "Since Julia code needs no prior compilation, it is possible to integrate very tightly and natively with a larger ROS system. Just make sure you:   Keep your code inside your ROS packages as usual.  Ensure your .jl script is executable (e.g.,  chmod a+x script.jl ) and has   the hint to the Julia binary as the first line ( #!/usr/bin/env julia ).  Now your Julia code will run exactly like any python script that gets invoked through  rosrun  or  roslaunch . And since  include  takes paths relative to the location of the calling file, you can bring in whatever other modules or functions reside in your package from the single executable script.  1\n2\n3\n4\n5\n6\n7 #!/usr/bin/env julia  #main.jl in thebot_pkg/src  using   RobotOS  include ( BotSrc/Bot.jl )  using   Bot  #...", 
            "title": "ROS Integration"
        }, 
        {
            "location": "/#full-example", 
            "text": "This example demonstrates publishing a random  geometry_msgs/Point  message at 5 Hz. It also listens for incoming  geometry_msgs/Pose2D  messages and republishes them as Points.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31 #!/usr/bin/env julia  using   RobotOS  @ rosimport   geometry_msgs . msg :   Point ,   Pose2D  rostypegen ()  using   geometry_msgs . msg  function  callback ( msg :: Pose2D ,   pub_obj :: Publisher { Point }) \n     pt_msg   =   Point ( msg . x ,   msg . y ,   0.0 ) \n     publish ( pub_obj ,   pt_msg )  end  function  loop ( pub_obj ) \n     loop_rate   =   Rate ( 5.0 ) \n     while   !   is_shutdown () \n         npt   =   Point ( rand (),   rand (),   0.0 ) \n         publish ( pub_obj ,   npt ) \n         rossleep ( loop_rate ) \n     end  end  function  main () \n     init_node ( rosjl_example ) \n     pub   =   Publisher { Point }( pts ,   queue_size = 10 ) \n     sub   =   Subscriber { Pose2D }( pose ,   callback ,   ( pub ,),   queue_size = 10 ) \n     loop ( pub )  end  if   !   isinteractive () \n     main ()  end", 
            "title": "Full example"
        }, 
        {
            "location": "/#versions", 
            "text": "0.1  : Initial release  0.2  : Changed type gen API and moved generated modules to Main  0.3  : Added service type generation and API  0.4  : Julia v0.4+ support only  0.5  : Docs website, Julia v0.5+ support only  0.6  : Julia v0.6+ support only", 
            "title": "Versions"
        }, 
        {
            "location": "/api/", 
            "text": "API Reference\n\n\n\n\nROS Type Generation\n\n\n#\n\n\nRobotOS.@rosimport\n \n \nMacro\n.\n\n\n@\nrosimport\n\n\n\n\n\n\nImport ROS message or service types into Julia. Call \nrostypegen()\n after all \n@rosimport\n calls. Package or type dependencies are also imported automatically as needed.\n\n\nExample usages:\n\n\n  \n@\nrosimport\n \ngeometry_msgs\n.\nmsg\n.\nPoseStamped\n\n  \n@\nrosimport\n \nsensor_msgs\n.\nmsg\n:\n \nImage\n,\n \nImu\n\n  \n@\nrosimport\n \nnav_msgs\n.\nsrv\n.\nGetPlan\n\n\n\n\n\n\n#\n\n\nRobotOS.rostypegen\n \n \nFunction\n.\n\n\nrostypegen\n(\nrosrootmod\n::\nModule\n=\nMain\n)\n\n\n\n\n\n\nInitiate the Julia type generation process after importing some ROS types. Creates modules in rootrosmod (default is \nMain\n) with the same behavior as imported ROS modules in python. Should only be called once, after all \n@rosimport\n statements are done.\n\n\n#\n\n\nRobotOS.rostypereset\n \n \nFunction\n.\n\n\nrostypereset\n()\n\n\n\n\n\n\nClear out the previous \n@rosimport\ns, returning the type generation to its original state. Cannot do anything about already generated modules in \nMain\n.\n\n\n\n\nPublishing and Subscribing\n\n\n#\n\n\nRobotOS.Publisher\n \n \nType\n.\n\n\nPublisher\n{\nT\n}(\ntopic\n;\n \nkwargs\n...)\n\n\nPublisher\n(\ntopic\n,\n \nT\n;\n \nkwargs\n...)\n\n\n\n\n\n\nCreate an object to publish messages of type \nT\n on a topic. Keyword arguments are directly passed to rospy.\n\n\n#\n\n\nRobotOS.publish\n \n \nFunction\n.\n\n\npublish\n(\np\n::\nPublisher\n{\nT\n},\n \nmsg\n::\nT\n)\n\n\n\n\n\n\nPublish \nmsg\n on \np\n, a \nPublisher\n with matching message type.\n\n\n#\n\n\nRobotOS.Subscriber\n \n \nType\n.\n\n\nSubscriber\n{\nT\n}(\ntopic\n,\n \ncallback\n,\n \ncb_args\n=\n();\n \nkwargs\n...)\n\n\nSubscriber\n(\ntopic\n,\n \nT\n,\n \ncallback\n,\n \ncb_args\n=\n();\n \nkwargs\n...)\n\n\n\n\n\n\nCreate a subscription to a topic with message type \nT\n with a callback to use when a message is received, which can be any callable type. Extra arguments provided to the callback when invoked can be provided in the \ncb_args\n tuple. Keyword arguments are directly passed to rospy.\n\n\n\n\nServices\n\n\n#\n\n\nRobotOS.Service\n \n \nType\n.\n\n\nService\n{\nT\n}(\nname\n,\n \ncallback\n;\n \nkwargs\n...)\n\n\nService\n(\nname\n,\n \nT\n,\n \ncallback\n;\n \nkwargs\n...)\n\n\n\n\n\n\nCreate a service object that can receive requests and provide responses. The callback can be of any callable type. Keyword arguments are directly passed to rospy.\n\n\n#\n\n\nRobotOS.ServiceProxy\n \n \nType\n.\n\n\nServiceProxy\n{\nT\n}(\nname\n;\n \nkwargs\n...)\n\n\nServiceProxy\n(\nname\n,\n \nT\n;\n \nkwargs\n...)\n\n\n\n\n\n\nCreate a proxy object used to invoke a remote service. Use \nsrv_proxy(msg_request)\n with the object to invoke the service call. Keyword arguments are directly passed to rospy.\n\n\n#\n\n\nRobotOS.wait_for_service\n \n \nFunction\n.\n\n\nwait_for_service\n(\nsrv_name\n;\n \nkwargs\n...)\n\n\n\n\n\n\nBlock until the specified service is available. Keyword arguments are directly passed to rospy. Throws an exception if the waiting timeout period is exceeded.\n\n\n\n\nGeneral ROS Functions\n\n\n#\n\n\nRobotOS.init_node\n \n \nFunction\n.\n\n\ninit_node\n(\nname\n;\n \nargs\n...)\n\n\n\n\n\n\nInitialize this node, registering it with the ROS master. All arguments are passed on directly to the rospy init_node function.\n\n\n#\n\n\nRobotOS.is_shutdown\n \n \nFunction\n.\n\n\nis_shutdown\n()\n\n\n\n\n\n\nReturn the shutdown status of the node.\n\n\n#\n\n\nRobotOS.spin\n \n \nFunction\n.\n\n\nspin\n()\n\n\n\n\n\n\nBlock execution and process callbacks/service calls until the node is shut down.\n\n\n\n\nTime Handling\n\n\n#\n\n\nRobotOS.Time\n \n \nType\n.\n\n\nTime\n(\nsecs\n,\n \nnsecs\n),\n \nTime\n(),\n \nTime\n(\nt\n::\nReal\n)\n\n\n\n\n\n\nObject representing an absolute time from a fixed past reference point at nanosecond precision.\n\n\nBasic arithmetic can be performed on combinations of \nTime\n and \nDuration\n objects that make sense. For example, if \nt::Time\n and \nd::Duration\n, \nt+d\n will be a \nTime\n, \nd+d\n a \nDuration\n, \nt-d\n a \nTime\n, \nd-d\n a \nDuration\n, and \nt-t\n a \nDuration\n.\n\n\n#\n\n\nRobotOS.Duration\n \n \nType\n.\n\n\nDuration\n(\nsecs\n,\n \nnsecs\n),\n \nDuration\n(),\n \nDuration\n(\nt\n::\nReal\n)\n\n\n\n\n\n\nObject representing a relative period of time at nanosecond precision.\n\n\nBasic arithmetic can be performed on combinations of \nTime\n and \nDuration\n objects that make sense. For example, if \nt::Time\n and \nd::Duration\n, \nt+d\n will be a \nTime\n, \nd+d\n a \nDuration\n, \nt-d\n a \nTime\n, \nd-d\n a \nDuration\n, and \nt-t\n a \nDuration\n.\n\n\n#\n\n\nRobotOS.Rate\n \n \nType\n.\n\n\nRate\n(\nhz\n::\nReal\n),\n \nRate\n(\nd\n::\nDuration\n)\n\n\n\n\n\n\nUsed to allow a loop to run at a fixed rate. Construct with a frequency or \nDuration\n and use with \nrossleep\n or \nsleep\n. The rate object will record execution time of other work in the loop and modify the sleep time to compensate, keeping the loop rate as consistent as possible.\n\n\n#\n\n\nRobotOS.to_sec\n \n \nFunction\n.\n\n\nto_sec\n(\nt\n)\n\n\n\n\n\n\nReturn the value of a ROS time object in absolute seconds (with nanosecond precision)\n\n\n#\n\n\nRobotOS.to_nsec\n \n \nFunction\n.\n\n\nto_nsec\n(\nt\n)\n\n\n\n\n\n\nReturn the value of a ROS time object in nanoseconds as an integer.\n\n\n#\n\n\nRobotOS.now\n \n \nFunction\n.\n\n\nRobotOS\n.\nnow\n()\n\n\n\n\n\n\nReturn the current ROS time as a \nTime\n object.\n\n\n#\n\n\nRobotOS.get_rostime\n \n \nFunction\n.\n\n\nget_rostime\n()\n\n\n\n\n\n\nReturn the current ROS time as a \nTime\n object.\n\n\n#\n\n\nRobotOS.rossleep\n \n \nFunction\n.\n\n\nrossleep\n(\nt\n)\n\n\n\n\n\n\nSleep and process callbacks for a number of seconds implied by the type and value of \nt\n, which may be a real-value, a \nDuration\n object, or a \nRate\n object.\n\n\n#\n\n\nBase.sleep\n \n \nFunction\n.\n\n\nsleep\n(\nt\n::\nDuration\n),\n \nsleep\n(\nt\n::\nRate\n)\n\n\n\n\n\n\nCall \nrossleep\n with a \nDuration\n or \nRate\n object. Use \nrossleep\n to specify sleep time directly.\n\n\n\n\nParameters\n\n\n#\n\n\nRobotOS.get_param\n \n \nFunction\n.\n\n\nget_param\n(\nparam_name\n,\n \ndefault\n=\nnothing\n)\n\n\n\n\n\n\nRequest the value of a parameter from the parameter server, with optional default value. If no default is given, throws a \nKeyError\n if the parameter cannot be found.\n\n\n#\n\n\nRobotOS.set_param\n \n \nFunction\n.\n\n\nset_param\n(\nparam_name\n,\n \nval\n)\n\n\n\n\n\n\nSet the value of a parameter on the parameter server.\n\n\n#\n\n\nRobotOS.has_param\n \n \nFunction\n.\n\n\nhas_param\n(\nparam_name\n)\n\n\n\n\n\n\nReturn a boolean specifying if a parameter exists on the parameter server.\n\n\n#\n\n\nRobotOS.delete_param\n \n \nFunction\n.\n\n\ndelete_param\n(\nparam_name\n)\n\n\n\n\n\n\nDelete a parameter from the parameter server. Throws a \nKeyError\n if no such parameter exists.\n\n\n\n\nLogging\n\n\n#\n\n\nRobotOS.logdebug\n \n \nFunction\n.\n\n\nlogdebug\n,\n \nloginfo\n,\n \nlogwarn\n,\n \nlogerr\n,\n \nlogfatal\n\n\n\n\n\n\nCall the rospy logging system at the corresponding message level, passing a message and other arguments directly.\n\n\n#\n\n\nRobotOS.loginfo\n \n \nFunction\n.\n\n\nlogdebug\n,\n \nloginfo\n,\n \nlogwarn\n,\n \nlogerr\n,\n \nlogfatal\n\n\n\n\n\n\nCall the rospy logging system at the corresponding message level, passing a message and other arguments directly.\n\n\n#\n\n\nRobotOS.logwarn\n \n \nFunction\n.\n\n\nlogdebug\n,\n \nloginfo\n,\n \nlogwarn\n,\n \nlogerr\n,\n \nlogfatal\n\n\n\n\n\n\nCall the rospy logging system at the corresponding message level, passing a message and other arguments directly.\n\n\n#\n\n\nRobotOS.logerr\n \n \nFunction\n.\n\n\nlogdebug\n,\n \nloginfo\n,\n \nlogwarn\n,\n \nlogerr\n,\n \nlogfatal\n\n\n\n\n\n\nCall the rospy logging system at the corresponding message level, passing a message and other arguments directly.\n\n\n#\n\n\nRobotOS.logfatal\n \n \nFunction\n.\n\n\nlogdebug\n,\n \nloginfo\n,\n \nlogwarn\n,\n \nlogerr\n,\n \nlogfatal\n\n\n\n\n\n\nCall the rospy logging system at the corresponding message level, passing a message and other arguments directly.", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/api/#ros-type-generation", 
            "text": "#  RobotOS.@rosimport     Macro .  @ rosimport   Import ROS message or service types into Julia. Call  rostypegen()  after all  @rosimport  calls. Package or type dependencies are also imported automatically as needed.  Example usages:     @ rosimport   geometry_msgs . msg . PoseStamped \n   @ rosimport   sensor_msgs . msg :   Image ,   Imu \n   @ rosimport   nav_msgs . srv . GetPlan   #  RobotOS.rostypegen     Function .  rostypegen ( rosrootmod :: Module = Main )   Initiate the Julia type generation process after importing some ROS types. Creates modules in rootrosmod (default is  Main ) with the same behavior as imported ROS modules in python. Should only be called once, after all  @rosimport  statements are done.  #  RobotOS.rostypereset     Function .  rostypereset ()   Clear out the previous  @rosimport s, returning the type generation to its original state. Cannot do anything about already generated modules in  Main .", 
            "title": "ROS Type Generation"
        }, 
        {
            "location": "/api/#publishing-and-subscribing", 
            "text": "#  RobotOS.Publisher     Type .  Publisher { T }( topic ;   kwargs ...)  Publisher ( topic ,   T ;   kwargs ...)   Create an object to publish messages of type  T  on a topic. Keyword arguments are directly passed to rospy.  #  RobotOS.publish     Function .  publish ( p :: Publisher { T },   msg :: T )   Publish  msg  on  p , a  Publisher  with matching message type.  #  RobotOS.Subscriber     Type .  Subscriber { T }( topic ,   callback ,   cb_args = ();   kwargs ...)  Subscriber ( topic ,   T ,   callback ,   cb_args = ();   kwargs ...)   Create a subscription to a topic with message type  T  with a callback to use when a message is received, which can be any callable type. Extra arguments provided to the callback when invoked can be provided in the  cb_args  tuple. Keyword arguments are directly passed to rospy.", 
            "title": "Publishing and Subscribing"
        }, 
        {
            "location": "/api/#services", 
            "text": "#  RobotOS.Service     Type .  Service { T }( name ,   callback ;   kwargs ...)  Service ( name ,   T ,   callback ;   kwargs ...)   Create a service object that can receive requests and provide responses. The callback can be of any callable type. Keyword arguments are directly passed to rospy.  #  RobotOS.ServiceProxy     Type .  ServiceProxy { T }( name ;   kwargs ...)  ServiceProxy ( name ,   T ;   kwargs ...)   Create a proxy object used to invoke a remote service. Use  srv_proxy(msg_request)  with the object to invoke the service call. Keyword arguments are directly passed to rospy.  #  RobotOS.wait_for_service     Function .  wait_for_service ( srv_name ;   kwargs ...)   Block until the specified service is available. Keyword arguments are directly passed to rospy. Throws an exception if the waiting timeout period is exceeded.", 
            "title": "Services"
        }, 
        {
            "location": "/api/#general-ros-functions", 
            "text": "#  RobotOS.init_node     Function .  init_node ( name ;   args ...)   Initialize this node, registering it with the ROS master. All arguments are passed on directly to the rospy init_node function.  #  RobotOS.is_shutdown     Function .  is_shutdown ()   Return the shutdown status of the node.  #  RobotOS.spin     Function .  spin ()   Block execution and process callbacks/service calls until the node is shut down.", 
            "title": "General ROS Functions"
        }, 
        {
            "location": "/api/#time-handling", 
            "text": "#  RobotOS.Time     Type .  Time ( secs ,   nsecs ),   Time (),   Time ( t :: Real )   Object representing an absolute time from a fixed past reference point at nanosecond precision.  Basic arithmetic can be performed on combinations of  Time  and  Duration  objects that make sense. For example, if  t::Time  and  d::Duration ,  t+d  will be a  Time ,  d+d  a  Duration ,  t-d  a  Time ,  d-d  a  Duration , and  t-t  a  Duration .  #  RobotOS.Duration     Type .  Duration ( secs ,   nsecs ),   Duration (),   Duration ( t :: Real )   Object representing a relative period of time at nanosecond precision.  Basic arithmetic can be performed on combinations of  Time  and  Duration  objects that make sense. For example, if  t::Time  and  d::Duration ,  t+d  will be a  Time ,  d+d  a  Duration ,  t-d  a  Time ,  d-d  a  Duration , and  t-t  a  Duration .  #  RobotOS.Rate     Type .  Rate ( hz :: Real ),   Rate ( d :: Duration )   Used to allow a loop to run at a fixed rate. Construct with a frequency or  Duration  and use with  rossleep  or  sleep . The rate object will record execution time of other work in the loop and modify the sleep time to compensate, keeping the loop rate as consistent as possible.  #  RobotOS.to_sec     Function .  to_sec ( t )   Return the value of a ROS time object in absolute seconds (with nanosecond precision)  #  RobotOS.to_nsec     Function .  to_nsec ( t )   Return the value of a ROS time object in nanoseconds as an integer.  #  RobotOS.now     Function .  RobotOS . now ()   Return the current ROS time as a  Time  object.  #  RobotOS.get_rostime     Function .  get_rostime ()   Return the current ROS time as a  Time  object.  #  RobotOS.rossleep     Function .  rossleep ( t )   Sleep and process callbacks for a number of seconds implied by the type and value of  t , which may be a real-value, a  Duration  object, or a  Rate  object.  #  Base.sleep     Function .  sleep ( t :: Duration ),   sleep ( t :: Rate )   Call  rossleep  with a  Duration  or  Rate  object. Use  rossleep  to specify sleep time directly.", 
            "title": "Time Handling"
        }, 
        {
            "location": "/api/#parameters", 
            "text": "#  RobotOS.get_param     Function .  get_param ( param_name ,   default = nothing )   Request the value of a parameter from the parameter server, with optional default value. If no default is given, throws a  KeyError  if the parameter cannot be found.  #  RobotOS.set_param     Function .  set_param ( param_name ,   val )   Set the value of a parameter on the parameter server.  #  RobotOS.has_param     Function .  has_param ( param_name )   Return a boolean specifying if a parameter exists on the parameter server.  #  RobotOS.delete_param     Function .  delete_param ( param_name )   Delete a parameter from the parameter server. Throws a  KeyError  if no such parameter exists.", 
            "title": "Parameters"
        }, 
        {
            "location": "/api/#logging", 
            "text": "#  RobotOS.logdebug     Function .  logdebug ,   loginfo ,   logwarn ,   logerr ,   logfatal   Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.  #  RobotOS.loginfo     Function .  logdebug ,   loginfo ,   logwarn ,   logerr ,   logfatal   Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.  #  RobotOS.logwarn     Function .  logdebug ,   loginfo ,   logwarn ,   logerr ,   logfatal   Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.  #  RobotOS.logerr     Function .  logdebug ,   loginfo ,   logwarn ,   logerr ,   logfatal   Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.  #  RobotOS.logfatal     Function .  logdebug ,   loginfo ,   logwarn ,   logerr ,   logfatal   Call the rospy logging system at the corresponding message level, passing a message and other arguments directly.", 
            "title": "Logging"
        }
    ]
}